# Authentication System and Patterns - NextGeag BP

## üö® CRITICAL WARNING FOR LLMs

**FOLLOW THESE PATTERNS EXACTLY - NO EXCEPTIONS**

The authentication system has been extensively tested and optimized. When creating new components or pages that require authentication:

- **ALWAYS** use server-side data fetching for authentication state
- **NEVER** use client-side only authentication for protected content
- **MUST** follow the server component + client component pattern
- **REQUIRED** to use `export const dynamic = 'force-dynamic'` for authentication-dependent components
- **FORBIDDEN** to use `createClient()` for authentication in server components

## Authentication Architecture Overview

The application uses a **server-first authentication system** with Next.js 13+ App Router:

1. **Supabase Auth**: JWT-based authentication with server-side validation
2. **Server-Side Session Management**: All authentication state managed server-side
3. **Client-Side Interactivity**: Only UI interactions handled client-side
4. **Server Actions**: Authentication operations (login, logout) handled server-side

## Core Problem: Why Client-Side Authentication Fails

### The State Synchronization Issue

```typescript
// ‚ùå PROBLEMATIC: Client-side authentication
'use client'
const supabase = createClient() // Browser-based auth state
const { data } = await supabase.auth.signInWithPassword(...)
// Client state updates, but server doesn't know about it immediately
```

**Problems:**
- Server components cache authentication state
- Client and server have different auth states
- Hydration mismatches between server and client rendering
- Redirects don't clear server-side cache

### The Solution: Server-Side Authentication Pattern

```typescript
// ‚úÖ CORRECT: Server-side authentication
export const dynamic = 'force-dynamic' // Prevent caching
const supabase = createServerClient(cookieStore) // Server-side client
const { data: { user } } = await supabase.auth.getUser() // Fresh data every time
```

## Authentication Components and Patterns

### 1. Server Components (Authentication State)

**File Pattern**: `page.tsx` or main component files

```typescript
import { createServerClient } from '@/lib/supabase'
import { cookies } from 'next/headers'
import { redirect } from 'next/navigation'
import ClientComponent from './client-component'

export const dynamic = 'force-dynamic'

export default async function ProtectedPage() {
  const cookieStore = await cookies()
  const supabase = createServerClient(cookieStore)
  
  if (!supabase) {
    redirect('/login')
  }

  // Fetch authentication state server-side
  const { data: { user }, error } = await supabase.auth.getUser()
  
  if (error || !user) {
    redirect('/login')
  }

  // Fetch additional user data
  const { data: adminSettings } = await supabase
    .from('admin_settings')
    .select('*')
    .limit(1)
    .maybeSingle()

  // Pass data to client component
  return <ClientComponent user={user} adminSettings={adminSettings} />
}
```

### 2. Client Components (Interactivity Only)

**File Pattern**: `component-name.tsx` or `*-form.tsx`

```typescript
'use client'

import { useState } from 'react'
import { signOut } from '@/app/actions/auth' // Server action

interface ClientComponentProps {
  user: any
  adminSettings: any
}

export default function ClientComponent({ user, adminSettings }: ClientComponentProps) {
  const [isLoading, setIsLoading] = useState(false)

  const handleSignOut = async () => {
    setIsLoading(true)
    try {
      await signOut() // Server action handles the actual sign out
    } catch (error) {
      console.error('Sign out failed:', error)
    }
  }

  return (
    <div>
      <p>Welcome, {user.email}</p>
      <button onClick={handleSignOut} disabled={isLoading}>
        {isLoading ? 'Signing out...' : 'Sign Out'}
      </button>
    </div>
  )
}
```

### 3. Server Actions (Authentication Operations)

**File Pattern**: `app/actions/auth.ts`

```typescript
'use server'

import { createServerClient } from '@/lib/supabase'
import { cookies } from 'next/headers'
import { redirect } from 'next/navigation'

export async function signOut() {
  const cookieStore = await cookies()
  const supabase = createServerClient(cookieStore)
  
  if (!supabase) {
    redirect('/login')
  }
  
  try {
    await supabase.auth.signOut()
    redirect('/login')
  } catch (error) {
    console.error('Error signing out:', error)
    redirect('/login')
  }
}

export async function signIn(formData: FormData) {
  const cookieStore = await cookies()
  const supabase = createServerClient(cookieStore)
  
  if (!supabase) {
    throw new Error('Unable to initialize Supabase client')
  }
  
  const email = formData.get('email') as string
  const password = formData.get('password') as string
  
  if (!email || !password) {
    throw new Error('Email and password are required')
  }
  
  try {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    })
    
    if (error) {
      throw new Error(error.message)
    }
    
    if (data.user) {
      redirect('/dashboard')
    }
  } catch (error) {
    throw error
  }
}
```

## LLM Instructions for Creating New Authenticated Components

### When Creating New Pages That Require Authentication:

1. **ALWAYS start with a server component** that fetches authentication state
2. **ALWAYS add `export const dynamic = 'force-dynamic'`** to prevent caching
3. **ALWAYS use `createServerClient(cookieStore)`** for server-side operations
4. **ALWAYS redirect to `/login`** if user is not authenticated
5. **ALWAYS pass authentication data as props** to client components

### When Creating New Interactive Components:

1. **ALWAYS use `'use client'`** directive for client components
2. **ALWAYS receive authentication data as props** from server components
3. **ALWAYS use server actions** for authentication operations (login, logout)
4. **NEVER use `createClient()`** for authentication in client components
5. **NEVER manage authentication state** in client components

### When Creating Forms That Require Authentication:

1. **ALWAYS use server actions** for form submissions
2. **ALWAYS handle loading states** properly
3. **ALWAYS use `window.location.replace()`** for redirects after authentication
4. **NEVER use `router.push()`** for authentication redirects
5. **NEVER set loading to false** when redirecting (causes spinner issues)

## Common Patterns and Examples

### Protected Page Pattern

```typescript
// app/protected-page/page.tsx
import { createServerClient } from '@/lib/supabase'
import { cookies } from 'next/headers'
import { redirect } from 'next/navigation'
import ProtectedPageClient from './protected-page-client'

export const dynamic = 'force-dynamic'

export default async function ProtectedPage() {
  const cookieStore = await cookies()
  const supabase = createServerClient(cookieStore)
  
  if (!supabase) {
    redirect('/login')
  }

  const { data: { user }, error } = await supabase.auth.getUser()
  
  if (error || !user) {
    redirect('/login')
  }

  // Fetch any additional data needed
  const { data: userData } = await supabase
    .from('user_data')
    .select('*')
    .eq('UID', user.id)
    .single()

  return <ProtectedPageClient user={user} userData={userData} />
}
```

### Login Form Pattern

```typescript
// app/login/login-form.tsx
'use client'

import { useState } from 'react'
import { createClient } from '@/lib/supabase'
import { useToast } from '@/hooks/use-toast'

interface LoginFormProps {
  adminSettings: any
}

export default function LoginForm({ adminSettings }: LoginFormProps) {
  const [isLoading, setIsLoading] = useState(false)
  const { toast } = useToast()
  const supabase = createClient()

  const handleSubmit = async (data: any) => {
    setIsLoading(true)

    try {
      const { data: authData, error } = await supabase.auth.signInWithPassword({
        email: data.email,
        password: data.password
      })

      if (error) {
        toast({
          title: 'Login Failed',
          description: error.message,
          variant: 'destructive'
        })
        setIsLoading(false)
      } else if (authData.user) {
        toast({
          title: 'Welcome back!',
          description: 'You have been successfully logged in.'
        })
        // Use replace to force hard refresh
        window.location.replace('/dashboard')
        // Don't set loading to false - we're redirecting
      }
    } catch (error) {
      toast({
        title: 'Error',
        description: 'An unexpected error occurred',
        variant: 'destructive'
      })
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Signing in...' : 'Sign In'}
      </button>
    </form>
  )
}
```

### Navigation Pattern

```typescript
// components/navigation.tsx
import { createServerClient } from '@/lib/supabase'
import { cookies } from 'next/headers'
import NavigationClient from './navigation-client'

export const dynamic = 'force-dynamic'

export default async function Navigation() {
  const cookieStore = await cookies()
  const supabase = createServerClient(cookieStore)
  
  if (!supabase) {
    throw new Error('Unable to initialize Supabase client')
  }

  const { data: { user }, error } = await supabase.auth.getUser()
  
  const { data: adminSettings } = await supabase
    .from('admin_settings')
    .select('*')
    .limit(1)
    .maybeSingle()

  return <NavigationClient user={user} adminSettings={adminSettings} />
}
```

## Critical Rules for LLMs

### ‚úÖ DO:

1. **Use server components** for authentication state fetching
2. **Add `dynamic = 'force-dynamic'`** to prevent caching
3. **Use `createServerClient(cookieStore)`** for server-side operations
4. **Use server actions** for authentication operations
5. **Pass authentication data as props** to client components
6. **Use `window.location.replace()`** for authentication redirects
7. **Handle loading states** properly in forms

### ‚ùå DON'T:

1. **Use `createClient()`** in server components
2. **Use `router.push()`** for authentication redirects
3. **Set loading to false** when redirecting after authentication
4. **Use client-side only authentication** for protected content
5. **Cache authentication state** without `dynamic = 'force-dynamic'`
6. **Manage authentication state** in client components

## Troubleshooting Common Issues

### Issue: Navigation not updating after login
**Solution**: Add `export const dynamic = 'force-dynamic'` to navigation component

### Issue: Login redirect not working
**Solution**: Use `window.location.replace('/dashboard')` instead of `router.push()`

### Issue: Sign out button not working after refresh
**Solution**: Use server actions for sign out operations

### Issue: Spinner stuck on login button
**Solution**: Don't set loading to false when redirecting after successful authentication

### Issue: Authentication state mismatch between client and server
**Solution**: Always fetch authentication state server-side and pass as props

## Admin Settings Pattern

### Server-Side Admin Settings Function

```typescript
// lib/admin-settings.ts
import { createServerClient } from '@/lib/supabase'
import { cookies } from 'next/headers'

export async function getServerAdminSettings() {
  const cookieStore = await cookies()
  const supabase = createServerClient(cookieStore)
  
  if (!supabase) {
    return null
  }

  try {
    const { data: adminSettings, error } = await supabase
      .from('admin_settings')
      .select('*')
      .limit(1)
      .maybeSingle()

    if (error) {
      console.error('Error fetching admin settings:', error)
      return null
    }

    return adminSettings
  } catch (error) {
    console.error('Error in getServerAdminSettings:', error)
    return null
  }
}

// Helper functions for button styling
export function getButtonStyles(adminSettings: any) {
  if (!adminSettings) {
    return {
      backgroundColor: '#000000',
      color: '#ffffff',
      borderColor: '#000000'
    }
  }

  return {
    backgroundColor: adminSettings.button_background_color || '#000000',
    color: adminSettings.button_text_color || '#ffffff',
    borderColor: adminSettings.button_border_color || '#000000'
  }
}

export function getButtonHoverStyles(adminSettings: any) {
  if (!adminSettings) {
    return {
      backgroundColor: '#333333',
      color: '#ffffff'
    }
  }

  return {
    backgroundColor: adminSettings.button_hover_background_color || '#333333',
    color: adminSettings.button_hover_text_color || '#ffffff'
  }
}
```

### Using Server-Side Admin Settings

```typescript
// Server component
import { getServerAdminSettings, getButtonStyles, getButtonHoverStyles } from '@/lib/admin-settings'

export default async function MyServerComponent() {
  const adminSettings = await getServerAdminSettings()
  
  return <ClientComponent 
    adminSettings={adminSettings}
    buttonStyles={getButtonStyles(adminSettings)}
    buttonHoverStyles={getButtonHoverStyles(adminSettings)}
  />
}
```

```typescript
// Client component
'use client'

interface ClientComponentProps {
  adminSettings: any
  buttonStyles: any
  buttonHoverStyles: any
}

export default function ClientComponent({ 
  adminSettings, 
  buttonStyles, 
  buttonHoverStyles 
}: ClientComponentProps) {
  return (
    <button style={buttonStyles}>
      Click me
    </button>
  )
}
```

## File Structure Guidelines

```
app/
‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îî‚îÄ‚îÄ auth.ts                    # Server actions for authentication
‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Server component (fetches admin settings)
‚îÇ   ‚îî‚îÄ‚îÄ login-form.tsx             # Client component (handles form)
‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îî‚îÄ‚îÄ page.tsx                   # Server component (fetches user data)
‚îî‚îÄ‚îÄ layout.tsx                     # Server component (fetches session)

components/
‚îú‚îÄ‚îÄ navigation.tsx                 # Server component (fetches user session)
‚îî‚îÄ‚îÄ navigation-client.tsx          # Client component (handles interactions)

lib/
‚îú‚îÄ‚îÄ auth.ts                        # Server-side auth utilities
‚îú‚îÄ‚îÄ admin-settings.ts              # Server-side admin settings utilities
‚îî‚îÄ‚îÄ supabase.ts                    # Supabase client configuration
```

## Summary

The key to successful authentication in this Next.js 13+ App Router application is:

1. **Server-side data fetching** for all authentication state
2. **Client-side interactivity** only for UI interactions
3. **Server actions** for authentication operations
4. **Dynamic rendering** to prevent caching issues
5. **Proper loading state management** to avoid UI issues

Follow these patterns exactly, and authentication will work consistently across both development and production environments.

